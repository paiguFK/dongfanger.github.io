

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6 深度剖析Python字典和集合（上） &mdash; 自动化代码美学 latest documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/js/readmore.js"></script>
        <script src="../_static/js/baidutongji.js"></script>
        <script src="../_static/js/valine.js"></script>
        <script src="../_static/js/Valine.min.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="7 深度剖析Python字典和集合（下）" href="007-%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%8B%EF%BC%89.html" />
    <link rel="prev" title="5 序列赋值引发的Python列表陷进" href="005-%E5%BA%8F%E5%88%97%E8%B5%8B%E5%80%BC%E5%BC%95%E5%8F%91%E7%9A%84Python%E5%88%97%E8%A1%A8%E9%99%B7%E8%BF%9B.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> 自动化代码美学
          

          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../preface.html">前言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/Python%E5%85%A5%E9%97%A8.html">Python入门</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../chapters/Python%E8%BF%9B%E9%98%B6.html">Python进阶</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="001-%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E6%8E%A8%E5%BC%80Python%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0%E5%A4%A7%E9%97%A8.html">1 魔法方法推开Python进阶学习大门</a></li>
<li class="toctree-l2"><a class="reference internal" href="002-Python%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8EPython%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.html">2 Python数据模型与Python对象模型</a></li>
<li class="toctree-l2"><a class="reference internal" href="003-Python%E5%85%83%E7%BB%84%E6%8B%86%E5%8C%85%E6%8D%A1%E5%88%B08%E5%80%8D%E9%95%9C%E5%BF%AB%E5%87%86%E7%8B%A0.html">3 Python元组拆包捡到8倍镜快准狠</a></li>
<li class="toctree-l2"><a class="reference internal" href="004-%E8%83%BD%E5%8F%96%E5%80%BC%E4%BA%A6%E8%83%BD%E8%B5%8B%E5%80%BC%E7%9A%84Python%E5%88%87%E7%89%87.html">4 能取值亦能赋值的Python切片</a></li>
<li class="toctree-l2"><a class="reference internal" href="005-%E5%BA%8F%E5%88%97%E8%B5%8B%E5%80%BC%E5%BC%95%E5%8F%91%E7%9A%84Python%E5%88%97%E8%A1%A8%E9%99%B7%E8%BF%9B.html">5 序列赋值引发的Python列表陷进</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6 深度剖析Python字典和集合（上）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">可散列的数据类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id2">散列表简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">字典</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mappingmutablemapping">Mapping和MutableMapping</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dict">dict构造方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">常见映射方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">鸭子类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="#update">update</a></li>
<li class="toctree-l4"><a class="reference internal" href="#setdefault">setdefault</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defaultdict">defaultdict字典变种</a></li>
<li class="toctree-l4"><a class="reference internal" href="#orderddict">OrderdDict及其他字典变种</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">不可变映射类型</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id7">小结</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="007-%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%8B%EF%BC%89.html">7 深度剖析Python字典和集合（下）</a></li>
<li class="toctree-l2"><a class="reference internal" href="008-%E5%8E%9F%E6%9D%A5Python%E5%87%BD%E6%95%B0%E5%8F%AA%E6%98%AF%E4%B8%AA%E5%AF%B9%E8%B1%A1.html">8 原来Python函数只是个对象</a></li>
<li class="toctree-l2"><a class="reference internal" href="009-Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E6%B3%A8%E8%A7%A3%E6%98%AF%E4%BB%80%E4%B9%88.html">9 Python函数参数和注解是什么</a></li>
<li class="toctree-l2"><a class="reference internal" href="010-Python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9F%A5%E5%A4%9A%E5%B0%91.html">10 Python设计模式知多少</a></li>
<li class="toctree-l2"><a class="reference internal" href="011-Python%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html">11 Python函数装饰器基础知识</a></li>
<li class="toctree-l2"><a class="reference internal" href="012-%E5%85%B3%E4%BA%8EPython%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%80%E5%88%87.html">12 关于Python闭包的一切</a></li>
<li class="toctree-l2"><a class="reference internal" href="999-%E6%B5%81%E7%95%85%E7%9A%84python%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html">999 流畅的python读书笔记</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/pytest%E5%8E%9F%E7%94%9F%E6%A1%86%E6%9E%B6.html">pytest原生框架</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/tep%E5%BC%80%E6%BA%90%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7.html">tep开源测试工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/teprunner%E5%BC%80%E6%BA%90%E6%B5%8B%E8%AF%95%E5%B9%B3%E5%8F%B0.html">teprunner开源测试平台</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/Django.html">Django</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/Django%20REST%20framework.html">Django REST framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/Locust.html">Locust</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/Java%E5%85%A5%E9%97%A8.html">Java入门</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/JMeter.html">JMeter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E5%A4%A7%E6%9D%82%E7%83%A9.html">大杂烩</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E9%9D%A2%E8%AF%95%E9%A2%98.html">面试题</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E8%A7%86%E9%A2%91%E6%BC%94%E7%A4%BA.html">视频演示</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93.html">年度总结</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapters/%E6%88%90%E9%95%BF%E5%B0%8F%E8%AF%B4.html">成长小说</a></li>
<li class="toctree-l1"><a class="reference internal" href="../aboutme.html">关于作者</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contact.html">联系方式</a></li>
<li class="toctree-l1"><a class="reference internal" href="../link.html">友情链接</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">自动化代码美学</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../chapters/Python%E8%BF%9B%E9%98%B6.html">Python进阶</a> &raquo;</li>
        
      <li>6 深度剖析Python字典和集合（上）</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Python进阶/006-深度剖析Python字典和集合（上）.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="python">
<h1>6 深度剖析Python字典和集合（上）<a class="headerlink" href="#python" title="Permalink to this headline">¶</a></h1>
<p><img alt="image1" src="../_images/wanggang6.png" /></p>
<p>“字典这个数据结构活跃在所有Python程序的背后，即便你的源码里并没有直接用到它”，摘抄自《代码之美》第18章Python的字典类：如何打造全能战士。字典是Python语言的基石！在函数的关键字参数、实例的属性和模块的命名空间都能够看到它的身影，我们自己写代码时也经常会用到。</p>
<p>“集合”这个概念在Python中算是比较年轻的，使用率也比较低，我只在元素去重和求差集并集时使用过。</p>
<p>字典和集合有个共同点，它们都是基于同一种数据结构实现的：散列表，又叫做哈希表，Hash
Table。要理解集合和字典，得先理解散列表。要理解散列表，得先理解可散列的数据类型。</p>
<div class="section" id="id1">
<h2>可散列的数据类型<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>在Python词汇表中，关于可散列类型的定义有这样一段话：</p>
<p>“如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现<code class="docutils literal notranslate"><span class="pre">__hash__（）</span></code>方法。另外可散列对象还要有<code class="docutils literal notranslate"><span class="pre">__eq__()</span></code>方法，这样才能跟其他键做比较。如果两个可散列对象是相等的，那么它们的散列值一定是一样的。”</p>
<p>重点是散列值不变！</p>
<blockquote>
<div><p>字典的键必须是可散列的，否则变来变去就找不到映射了。</p>
</div></blockquote>
<p>于是可以得知原子不可变数据类型（str、bytes、和数值类型）都是可散列类型，frozenset冻结不可变集合，也是可散列的。元组有两种情况，一、如果所有元素都是可散列的数据类型，那么元组是可散列的，二、如果元组里面的元素是其他可变类型的引用，那么元组是不可散列的，示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tt</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span>
<span class="go">-3907003130834322577</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">tl</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;input&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">unhashable type: &#39;list&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">tf</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">([</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">hash</span><span class="p">(</span><span class="n">tf</span><span class="p">)</span>
<span class="go">5149391500123939311</span>
</pre></div>
</div>
<p>其中<code class="docutils literal notranslate"><span class="pre">tl</span></code>元组包含了列表（可变），<code class="docutils literal notranslate"><span class="pre">hash()</span></code>函数报错了。</p>
</div>
<div class="section" id="id2">
<h2>散列表简介<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>假设你们班级100个同学每个人的学号是由院系-年级-班级-编号组成，例如学号为01100168表示是01系-10级-01班-68号。为了快速查找到68号的成绩信息，可以建立一张表，但是不能用学号作为下标，学号的数值实在太大。因此将学号除以1100100取余，即得到编号作为该表的下标。要查找学号为01100168的成绩的时候，只要直接访问表下标为68的数据即可。</p>
<p>散列表就是一张表，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查询速度。这个映射函数称作散列函数，存放记录的表称作散列表。再举个例子，比如下面这几个人物，按数组存储：</p>
<p><img alt="image2" src="../_images/image-20210317095732318.png" /></p>
<p>这样我要找到沈嘉文的电话号码，需要顺序查找对比整个数组，第一个余罪，不是，第二个傅老大，不是，直到第三个才找到沈嘉文。换成散列表：</p>
<p><img alt="image3" src="../_images/image-20210317100131271.png" /></p>
<p>左边是姓名首字母的Key，右边是电话号码的Value，当我们要查找沈嘉文的时候，通过计算，在s位置，1次查找就找到了。</p>
<blockquote>
<div><p>为了不让本文显得生硬，接下来先介绍字典和集合，最后再看看散列表是如何实现它们的。</p>
</div></blockquote>
</div>
<div class="section" id="id3">
<h2>字典<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<div class="section" id="mappingmutablemapping">
<h3>Mapping和MutableMapping<a class="headerlink" href="#mappingmutablemapping" title="Permalink to this headline">¶</a></h3>
<p>Mapping和MutableMapping是collections.abc模块中的两个抽象基类，它们的作用是作为形式化的文档，定义了构建一个映射类型所需要的最基本的接口。比如判断是否是映射类型：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">abc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">my_dict</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>非抽象映射类型一般不会直接继承这两个抽象基类，而是会直接对dict或collections.UserDict进行扩展。正是如此，Python标准库里的所有映射类型都是利用dict来实现的。</p>
</div>
<div class="section" id="dict">
<h3>dict构造方法<a class="headerlink" href="#dict" title="Permalink to this headline">¶</a></h3>
<p>dict构造方法如下：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">one</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">two</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">three</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;one&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;two&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;three&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">([</span><span class="s2">&quot;one&quot;</span><span class="p">,</span> <span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="s2">&quot;three&quot;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;one&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;three&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">e</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">({</span><span class="s2">&quot;three&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;one&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;two&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">})</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span> <span class="o">==</span> <span class="n">d</span> <span class="o">==</span> <span class="n">e</span>
<span class="go">True</span>
</pre></div>
</div>
<p>一共竟然有五种！还有第六种：字典推导，跟列表推导和生成器表达式类似：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_list</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;two&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;one&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;three&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">en</span><span class="p">:</span> <span class="n">num</span> <span class="k">for</span> <span class="n">en</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_dict</span>
<span class="go">{&#39;two&#39;: 2, &#39;one&#39;: 1, &#39;three&#39;: 3}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>常见映射方法<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>除了dict，还有两个dict的变种：defaultdict和OrderedDict，它们对常见映射方法的支持区别如下：</p>
<p><img alt="image4" src="../_images/IMG_20210317_125311.jpg" /></p>
<p><img alt="image5" src="../_images/IMG_20210317_125414.jpg" /></p>
</div>
<div class="section" id="id5">
<h3>鸭子类型<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>鸭子类型是动态语言的说法，指一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。比如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The animal is running...&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Dog</span><span class="p">(</span><span class="n">Animal</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The dog is running...&#39;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Cat</span><span class="p">(</span><span class="n">Animal</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The cat is running...&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">make_run</span><span class="p">(</span><span class="n">animal</span><span class="p">):</span>
    <span class="n">animal</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">dog</span> <span class="o">=</span> <span class="n">Dog</span><span class="p">()</span>
<span class="n">cat</span> <span class="o">=</span> <span class="n">Cat</span><span class="p">()</span>
<span class="n">make_run</span><span class="p">(</span><span class="n">dog</span><span class="p">)</span>
<span class="n">make_run</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span>
</pre></div>
</div>
<p>对于 <code class="docutils literal notranslate"><span class="pre">make_run()</span></code> 函数来说，传入的参数并不一定需要是 <code class="docutils literal notranslate"><span class="pre">Animal</span></code>
类型的，只需要保证传入的对象有一个 <code class="docutils literal notranslate"><span class="pre">run()</span></code> 方法即可。</p>
<blockquote>
<div><p>在静态语言中，如果需要传入 <code class="docutils literal notranslate"><span class="pre">Animal</span></code> 类型，则传入的对象就必须是
<code class="docutils literal notranslate"><span class="pre">Animal</span></code> 类型或者它的子类，否则，将无法调用 <code class="docutils literal notranslate"><span class="pre">run()</span></code> 方法。</p>
</div></blockquote>
</div>
<div class="section" id="update">
<h3>update<a class="headerlink" href="#update" title="Permalink to this headline">¶</a></h3>
<p>update方法用来更新字典里对应的条目，它处理参数m的方式，是典型的“鸭子类型”。函数首先检查m是否有keys方法，如果有，那么update函数就把它当作映射对象来处理，不关心是不是真的映射类型。如果没有，函数会把m当作包含了键值对(key,
value)元素的迭代器。</p>
<blockquote>
<div><p>Python里大多数映射类型的构造方法都采用了类似的逻辑。</p>
</div></blockquote>
</div>
<div class="section" id="setdefault">
<h3>setdefault<a class="headerlink" href="#setdefault" title="Permalink to this headline">¶</a></h3>
<p>当字典d[k]不能找到正确的键的时候，Python会抛出异常。也许每个Python使用者都知道可以用d.get(k,
default)来代替d[k]，给找不到的键一个默认的返回值。但是要更新字典时，该怎么办呢？比如要在my_dict中添加键为b，值为列表[1,
2, 3, 4, 5, 6]的键值对：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span>
<span class="n">my_list</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>

<span class="c1">## {&quot;a&quot;: 1, &quot;b&quot;: [2, 3, 4, 5, 6]}</span>
</pre></div>
</div>
<blockquote>
<div><p>不能用<code class="docutils literal notranslate"><span class="pre">mylist[key]</span> <span class="pre">=</span> <span class="pre">my_list</span></code>，必须用for循环动态append。</p>
</div></blockquote>
<p>方法1，先添加空列表，再append：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">my_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
    <span class="n">my_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>方法2，第一次没有键，先用get查询返回空列表，再append，再赋值：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">my_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">temp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">my_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
</pre></div>
</div>
<p>方法3，先用if判断，再append：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">my_dict</span><span class="p">:</span>
        <span class="n">my_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">my_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>方法4，一行代码：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
    <span class="c1"># 除了for循环，一行代码</span>
    <span class="n">my_dict</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>Python骚操作总是这么多！setdefault你学会了么？</p>
<blockquote>
<div><p>setdefault只需要进行一次键查询就可以完成操作，节省键查询，程序更高效。</p>
</div></blockquote>
</div>
<div class="section" id="defaultdict">
<h3>defaultdict字典变种<a class="headerlink" href="#defaultdict" title="Permalink to this headline">¶</a></h3>
<p>有没有办法直接执行<code class="docutils literal notranslate"><span class="pre">my_dict[key].append(i)</span></code>呢？答案是有的，借助defaultdict可以实现：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">collections</span>

<span class="n">my_dict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
<span class="n">my_dict</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">key</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span>
<span class="n">my_list</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">my_list</span><span class="p">:</span>
    <span class="n">my_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
<p>my_dict[key]会按以下步骤执行：</p>
<ol class="arabic simple">
<li><p>调用list()来建立一个新列表。</p></li>
<li><p>把这个新列表作为值，key作为它的键，放到my_dict中。</p></li>
<li><p>返回这个列表的引用。</p></li>
</ol>
<p>通过列表引用继续执行append()函数。</p>
<p>defaultdict的<code class="docutils literal notranslate"><span class="pre">__init__(self,</span> <span class="pre">default_factory=None,</span> <span class="pre">**kwargs)</span></code>有个参数default_factory用来生成默认值，必须是可调用对象。比如：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">init_list</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">my_dict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="n">init_list</span><span class="p">)</span>
</pre></div>
</div>
<p>注意了！此时my_dict的值是{}空字典，default_factory只会在<code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>里被调用，也就是说<code class="docutils literal notranslate"><span class="pre">my_dict[key]</span></code>时才会用这个默认值：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">)</span>  <span class="c1"># defaultdict(&lt;function init_list at 0x014E84F0&gt;, {})</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_dict</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">])</span> <span class="c1"># defaultdict(&lt;function init_list at 0x014E84F0&gt;, {&#39;b&#39;: [0]})</span>
</pre></div>
</div>
<blockquote>
<div><p>my_dict.get(“b”)不会调用<code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>，不会使用default_factory，返回值为None。</p>
<p>为什么get不会调用<code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>?<code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>是为[]提供的语法糖，get()已经是取值方法了，不需要这个语法糖。</p>
</div></blockquote>
<p>default_factory默认为None，如果不指定，查询不存在的键会触发KeyError，这个道理和[]取值是一样的。</p>
<p>所有这一切背后的功臣其实是魔法方法<code class="docutils literal notranslate"><span class="pre">__missing__</span></code>。所有的映射类型在处理找不到的键的时候，都会牵扯到<code class="docutils literal notranslate"><span class="pre">__missing__</span></code>方法。基类dict并没有定义这个方法，但是dict是能知道它的，如果一个类继承了dict，然后实现了<code class="docutils literal notranslate"><span class="pre">__missing__</span></code>方法，Python就会自动调用它，而不是抛出一个KeyError异常。</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">__missing__</span></code>只会被<code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>调用，这就是default_factory只对<code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>有作用的原因！</p>
</div></blockquote>
<p>示例如下，当用非字符串键查询时，转换为字符串键查询：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StrKeyDict0</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>  <span class="c1"># &lt;1&gt;</span>

    <span class="k">def</span> <span class="fm">__missing__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>  <span class="c1"># &lt;2&gt; 不加这个判断，如果str(key)不存在，就会第3处再次调用__missing__无限递归</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>  <span class="c1"># &lt;3&gt;</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>  <span class="c1"># &lt;4&gt;</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>  <span class="c1"># &lt;5&gt;</span>

    <span class="c1"># k in my_dict 会导致__contains__递归调用，所以这里用了self.keys()</span>
    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">or</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>  <span class="c1"># &lt;6&gt;</span>
</pre></div>
</div>
<blockquote>
<div><p>像<code class="docutils literal notranslate"><span class="pre">k</span> <span class="pre">in</span> <span class="pre">my_dict.keys()</span></code>这种操作在Python3中是很快的，而且即便映射类型对象很庞大也没关系，这是因为dict.keys()的返回值是一个“视图”。</p>
</div></blockquote>
</div>
<div class="section" id="orderddict">
<h3>OrderdDict及其他字典变种<a class="headerlink" href="#orderddict" title="Permalink to this headline">¶</a></h3>
<p><strong>collections.OrderedDict</strong></p>
<p>在Django REST
framework中的分页就用到了OrderedDict，返回分页数据必须是有序的，否则会提示UnOrdered。OrderedDict的popitem方法默认删除并返回字典里的最后一个元素（栈），如果加了参数OrderedDict(last=False)，那么它会删除并返回第一个被添加进度的元素（队列）。</p>
<p><strong>collections.ChainMap</strong></p>
<p>示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">builtins</span>
<span class="n">pylookup</span> <span class="o">=</span> <span class="n">ChainMap</span><span class="p">(</span><span class="nb">locals</span><span class="p">(),</span> <span class="nb">globals</span><span class="p">(),</span> <span class="nb">vars</span><span class="p">(</span><span class="n">builtins</span><span class="p">))</span>
</pre></div>
</div>
<p>该类型可以容纳多个不同的映射对象，在按键查找时，这些对象会被当作一个整体被逐一查找。</p>
<p><strong>collections.Counter</strong></p>
<p>示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">collections</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="s2">&quot;abracadabra&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span>
<span class="go">Counter({&#39;a&#39;: 5, &#39;b&#39;: 2, &#39;r&#39;: 2, &#39;c&#39;: 1, &#39;d&#39;: 1})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s2">&quot;aaaaazzz&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span>
<span class="go">Counter({&#39;a&#39;: 10, &#39;z&#39;: 3, &#39;b&#39;: 2, &#39;r&#39;: 2, &#39;c&#39;: 1, &#39;d&#39;: 1})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span><span class="o">.</span><span class="n">most_common</span><span class="p">()</span>
<span class="go">[(&#39;a&#39;, 10), (&#39;z&#39;, 3), (&#39;b&#39;, 2), (&#39;r&#39;, 2), (&#39;c&#39;, 1), (&#39;d&#39;, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ct</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[(&#39;a&#39;, 10), (&#39;z&#39;, 3)]</span>
</pre></div>
</div>
<p>Counter是用来给可散列表对象计数的。</p>
<p><strong>collections.UserDict</strong></p>
<p>让用户继承写子类。</p>
<blockquote>
<div><p>它比dict更适合继承的原因是，后者有时会在某些方法的实现上走一些捷径，导致我们不得不在它的子类中重写这些方法，而UserDict就不需要。</p>
</div></blockquote>
</div>
<div class="section" id="id6">
<h3>不可变映射类型<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>借助MappingProxyType，可以实现不可变字典。它返回的是一个只读的视图，会跟随源字典动态展示，但是无法对源字典做出改动。示例：</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">MappingProxyType</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d_proxy</span> <span class="o">=</span> <span class="n">MappingProxyType</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d_proxy</span>
<span class="go">mappingproxy({1: &#39;A&#39;})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d_proxy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">&#39;A&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d_proxy</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;input&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">TypeError</span>: <span class="n">&#39;mappingproxy&#39; object does not support item assignment</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;B&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d_proxy</span>
<span class="go">mappingproxy({1: &#39;A&#39;, 2: &#39;B&#39;})</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id7">
<h2>小结<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>本文为上篇，主要介绍了散列表和字典，包含了一些Python骚操作，也用示例解释了什么是鸭子类型。下篇将介绍集合，以及散列表是如何实现dict和set的。</p>
<blockquote>
<div><p>参考资料：</p>
<p>《流畅的Python》</p>
<p><a class="reference external" href="https://zhuanlan.zhihu.com/p/64853220">https://zhuanlan.zhihu.com/p/64853220</a></p>
<p><a class="reference external" href="https://www.jianshu.com/p/101c263cd93e">https://www.jianshu.com/p/101c263cd93e</a></p>
<p><a class="reference external" href="http://www.woshipm.com/pmd/805326.html">http://www.woshipm.com/pmd/805326.html</a></p>
<p><a class="reference external" href="https://zhuanlan.zhihu.com/p/149463934?from_voters_page=true">https://zhuanlan.zhihu.com/p/149463934?from_voters_page=true</a></p>
<p><a class="reference external" href="https://www.jianshu.com/p/e97044a8169a">https://www.jianshu.com/p/e97044a8169a</a></p>
<p><a class="reference external" href="https://github.com/fluentpython/example-code/blob/master/03-dict-set/strkeydict0.py">https://github.com/fluentpython/example-code/blob/master/03-dict-set/strkeydict0.py</a></p>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="007-%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90Python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88%EF%BC%88%E4%B8%8B%EF%BC%89.html" class="btn btn-neutral float-right" title="7 深度剖析Python字典和集合（下）" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="005-%E5%BA%8F%E5%88%97%E8%B5%8B%E5%80%BC%E5%BC%95%E5%8F%91%E7%9A%84Python%E5%88%97%E8%A1%A8%E9%99%B7%E8%BF%9B.html" class="btn btn-neutral float-left" title="5 序列赋值引发的Python列表陷进" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright dongfanger

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>