序列赋值引发的Python列表陷进
============================

|image1|

序列赋值是Python默认操作，如果使用不当，有可能会掉入语法陷阱。

``+``
-----

``+``\ 是指把两个序列的元素拼接在一起。通常\ ``+``\ 号两侧的序列由相同类型的数据所构成，在拼接的过程中，两个被操作的序列都不会被修改，Python会新建一个包含同样类型数据的序列作为拼接的结果。比如：

.. code:: python

   a = [1]
   b = [2]
   c = a + b
   print(a, b, c)
   print(id(a), id(b), id(c))

结果为：

.. code:: python

   [1] [2] [1, 2]
   2409610524480 2409610523520 2409610523648

.. _section-1:

``*``
-----

如果想要把一个序列复制几份然后再拼接起来，更快捷的做法是把这个序列乘以一个整数。同样，这个操作会产生一个新序列：

.. code:: python

   >>> l = [1]
   >>> l * 5
   [1, 1, 1, 1, 1]
   >>> 5 * "a"
   'aaaaa'

..

   ``+``\ 和\ ``*``\ 都遵循这个规律，不修改原有的操作对象，而是构建一个全新的序列。

列表套列表的陷进
----------------

猜猜这个结果会是啥：

.. code:: python

   x = ["x"]
   my_list = [x] * 3
   print(my_list)  # [['x'], ['x'], ['x']]

   x2 = my_list[2]
   x2[0] = "y"
   print(my_list)

讲道理，应该是\ ``[['x'], ['x'], ['y']]``\ ，但是错了，实际是：

.. code:: python

   [['y'], ['y'], ['y']]

Unbelievable！给\ ``my_list``\ 的最后一个元素的列表赋值，结果所有三个元素的列表都被赋值了！这反映出\ ``my_list``\ 这三个元素不是3个列表，而是3个列表引用，指向了同一个相同的列表。相当于：

.. code:: python

   x = ["x"]
   my_list = []
   for i in range(3):
       my_list.append(x)  # 追加相同对象

   x2 = my_list[2]
   x2[0] = "y"
   print(my_list)  # [['y'], ['y'], ['y']]

每次都追加了同一个对象到\ ``my_list``\ 。

如果想生成3个不同列表，那么需要在每次迭代中新建列表：

.. code:: python

   my_list = []
   for i in range(3):
       x = ["x"]  # 新建列表
       my_list.append(x)

   x2 = my_list[2]
   x2[0] = "y"
   print(my_list)  # [['x'], ['x'], ['y']]

这样就符合预期了。可以用列表推导简化代码：

.. code:: python

   x = ["x"]
   my_list = [x for i range(3)]

   x2 = my_list[2]  
   x2[0] = "y"
   print(my_list)  # [['x'], ['x'], ['y']]

**教训：**

新建列表中的列表，使用列表推导，不要使用\ ``*``\ 运算符。

   如果\ ``a * n``\ 这个语句中，序列a里的元素是对其他可变对象的引用的话，就需要格外注意了，这可能不是你想要的效果。

.. _section-2:

``+=``
------

``a += b``\ 虽然意思是\ ``a = a + b``\ ，但是它背后的特殊方法是\ ``__iadd__``\ ，如果一个类没有实现这个方法的话，Python才会退一步调用\ ``__add__``\ 。\ ``__iadd__``\ 方法会直接在原对象中追加，\ ``__add__``\ 方法会先生成新对象再赋值。

.. _section-3:

``*=``
------

``+=``\ 的这些概念也适用于\ ``*=``\ ，只是后者对应的是\ ``__imul__``\ 。追加还是新对象，在作用到可变序列和不可变序列时效果明显，示例：

.. code:: python

   ## 可变序列，追加
   >>> l = [1, 2, 3]
   >>> id(l)
   2135319475136
   >>> l *= 2
   >>> l
   [1, 2, 3, 1, 2, 3]
   >>> id(l)
   2135319475136  # id一样

   ## 不可变序列，新对象
   >>> t = (1, 2, 3)
   >>> id(t)
   2135322139520
   >>> t *= 2
   >>> id(t)
   2135321695424  # id不一样

元组套列表的陷进
----------------

.. code:: python

   >>> t = (1, 2, [30, 40])
   >>> t[2] += [50, 60]

猜猜会发生下面4种情况中的哪一种？

a.t变成\ ``(1, 2, [30, 40, 50, 60])``

b.因为tuple不支持对它的元素赋值，所以会抛出TypeError异常

c.以上两个都不是

d.a和b都是对的

因为元组不能赋值，所以我会毫不犹豫的选择\ ``b``\ 。但实际上答案是\ ``d``\ ！a和b都是对的，既会赋值成功，也会报错：

.. code:: python

   >>> t = (1, 2, [30, 40])
   >>> t[2] += [50, 60]
   Traceback (most recent call last):
     File "<input>", line 1, in <module>
   TypeError: 'tuple' object does not support item assignment
   >>> t
   (1, 2, [30, 40, 50, 60])

Oh
No！为什么？一、赋值成功，因为\ ``t[2]``\ 指向的是一个可变对象（列表\ ``[30, 40]``\ ），可变对象是能赋值的。二、报错，因为可变对象赋值给了不可变对象（元组\ ``t``\ ），不可变对象不能赋值。

   写成\ ``t[2].extend([50, 60])``\ 能避免这个异常。

**教训：**

1. 不要把可变对象放在元组里面。
2. ``+=``\ 不是一个原子操作，虽然抛出了异常，但还是完成了操作。

..

   这位巴西作者说到，在他15年的Python生涯中，他还没见过谁在这个地方吃过亏。

小结
----

本文分别介绍了\ ``+``\ 、\ ``*``\ 和列表套列表的陷阱，\ ``+=``\ 、\ ``*=``\ 和元组套列表的陷阱，并分别得出了教训。这是动态语言的弊端，在运行后才能知道有没有类型错误，只能积累代码经验来避免。鱼与熊掌不可兼得，在享受Python语法简洁的便利同时，也得付出运行报错排查麻烦的代价。

   参考资料：

   《流畅的Python》

.. |image1| image:: ../wanggang.png
