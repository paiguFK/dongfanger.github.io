2 Java
======

|image1|

**Java的socket的server和client怎么实现，怎么互相发消息？**

::

   // server
   ServerSocket server = new ServerSocket(port);
   Socket socket = server.accept();
   InputStream in = socket.getInputStream();


   // client
   Socket socket = new Socket(host, port);
   out = socket.getOutputStream();
   out.write()
   out.flush()

**JVM中程序计数器区会不会报OOM异常？**

::

   不会。程序计数器存储的内容仅仅就是下一条待执行的命令的地址。

**说说乐观锁和悲观锁？**

::

   乐观锁，乐观的，假设别人不会修改数据，不会上锁。适用于写比较少的情况下（多读场景）。可以省去锁的开销，加大系统的吞吐量。
   悲观锁，悲观的，假设每次拿数据别人都会修改，上锁。适用于多写的场景，因为多写冲突会比较多，上层应用会不断的进行retry，这样反倒是降低了性能。

   延伸：
   Java中的乐观锁
   java.util.concurrent.atomic
   Java中的悲观锁
   synchronized和ReentrantLock

   乐观锁一般会使用版本号机制或CAS算法实现。

**线程sleep和wait的区别？**

::

   sleep是让线程休眠，wait是将调用者的线程挂起等待。
   sleep是Thread的静态方法，wait是Object的方法。
   sleep不会释放同步锁，wait会释放同步锁。

**Spring定时任务@Scheduled注解？**

::

   * * * * * * *
   1 秒（0~59）
   2 分钟（0~59）
   3 小时（0~23）
   4 天（0~31）
   5 月（0~11）
   6 星期（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）
   7 年份（1970－2099）  // 可能没有

   由于"月份中的日期"和"星期中的日期"这两个元素互斥的,必须要对其中一个设置?，表示不指定值
   “L” 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写。如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”表示这个月的倒数第６天

   例子：
   "0 0 12 * * ?" 每天中午12点触发
   "0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发
   "0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发
   “0/5”表示从第0分钟开始，每15分钟
   "0 15 10 L * ?" 每月最后一日的上午10:15触发
   "0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发

**Java方法参数匹配顺序？**

::

   1）精确匹配
   2）基本数据类型（自动转换成更大范围）
   3）封装类（自动拆箱与装箱）
   4）子类向上转型依次匹配
   5）可变参数匹配

**Tomcat三种运行模式？**

::

   BIO，一个线程处理一个请求。
   NIO，利用Java的异步IO处理，可以通过少量的线程处理大量的请求。
   APR，即Apache Portable Runtime，从操作系统层面解决io阻塞问题。

   延伸：
   Tomcat单进程多线程。
   Nginx多进程，一个主进程管理多个worker子进程。

**ArrayList和LinkedList区别？**

::

   ArrayList基于数组实现。LinkedList基于双向链表实现。
   随机访问，ArrayList优于LinkedList。
   插入和删除，LinkedList优于ArrayList。
   LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。

**将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。手写代码？**

::

   示例：
   输入：1->2->4, 1->3->4
   输出：1->1->2->3->4->4
      
   两个链表头部较小的一个与剩下元素的 merge 操作结果合并。

   /**
    * Definition for singly-linked list.
    * struct ListNode {
    *     int val;
    *     ListNode *next;
    *     ListNode(int x) : val(x), next(NULL) {}
    * };
    */

   class Solution {
       public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
           if (l1 == null) {
               return l2;
           }
           else if (l2 == null) {
               return l1;
           }
           else if (l1.val < l2.val) {
               l1.next = mergeTwoLists(l1.next, l2);
               return l1;
           }
           else {
               l2.next = mergeTwoLists(l1, l2.next);
               return l2;
           }

       }
   }

**Java接口与抽象类的区别？**

::

   从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。
   【方法】接口只能有抽象方法，抽象类可以有抽象方法和非抽象方法。Java8以后，接口可以直接定义default和static方法了。抽象类可以有protect和private方法。
   【成员变量】接口中的成员变量默认是static和final的，抽象类可以像常规的对象一样定义各种成员变量。可以是非static和final的。
   【实现】接口不能实现其他的接口，只能继承一个其它的接口。抽象类可以实现多个接口。
   【构造器】抽象类可以有构造器，接口不能有构造器。
   【main方法】抽象类可以有main方法，并且我们可以运行它。接口不能有main方法。
   【速度】抽象类速度更快一些，接口需要时间寻找类中的实现方法。

**说说继承和多态？**

::

   继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来类的情况下对这些功能进行扩展。

   多态是指，使用父对象的地方，可以用子对象来代替，这样在赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运行。
   实现多态，有两种方式，覆盖和重载。两者的区别在于：覆盖在运行时决定，重载是在编译时决定。并且覆盖和重载的机制不同。

**Java如何创建多线程？**

::

   继承Thread类
   实现Runnable接口
   使用Callable和Future创建线程

**有三个线程T1，T2，T3，怎么确保它们按顺序执行？**

::

   public class JoinTest2 {
    
       // 1.现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行
    
       public static void main(String[] args) {
    
           final Thread t1 = new Thread(new Runnable() {
    
               @Override
               public void run() {
                   System.out.println("t1");
               }
           });
           final Thread t2 = new Thread(new Runnable() {
    
               @Override
               public void run() {
                   try {
                       //引用t1线程，等待t1线程执行完
                       t1.join();
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
                   System.out.println("t2");
               }
           });
           Thread t3 = new Thread(new Runnable() {
    
               @Override
               public void run() {
                   try {
                       //引用t2线程，等待t2线程执行完
                       t2.join();
                   } catch (InterruptedException e) {
                       e.printStackTrace();
                   }
                   System.out.println("t3");
               }
           });
           t3.start();
           t2.start();
           t1.start();
       }
   }

**Thread 类中的start()和 run()方法有什么区别？**

::

   start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。

**线程安全的单例模式？**

::

   //延迟加载+Synchronized 
   public final class ThreadSafeSingleton  
   {  
       private static ThreadSafeSingleton singObj = null;  
     
       private ThreadSafeSingleton(){  
       }  
     
       public static Synchronized ThreadSafeSingleton getSingleInstance(){  
           if(null == singObj ) singObj = new ThreadSafeSingleton();
               return singObj；
       }  
   }

**说一下垃圾回收机制？**

::

   对内存堆中长时间没有使用的对象或没有引用的对象进行清除和回收，从而释放占用的空间，防止内存泄露。

**Java异常处理机制？**

::

   在方法中用 try catch 语句捕获并处理异常，catch 语句可以有多个，用来匹配多个异常。
   对于处理不了的异常或者要转型的异常，在方法的声明处通过 throws 语句拋出异常，即由上层的调用方法来处理。

**Java集合分为哪两大类？**

::

   Map和Collection。

**JVM中的内存分为哪五个部分？**

::

   方法区、堆、虚拟机栈、本地方法栈、程序计数器。
   方法区：存储加载的class字节码，通过该区域我们能寻址到类中的方法的入口。除此之外，方法区还包括运行时常量区和静态常量区。这个区域是所有线程共享的。
   堆：存储new出来的对象，垃圾回收器主要监控和回收的就是这块区域。在堆里面不断创建对象但是垃圾回收器不回收，就有可能造成OutOfMemoryError错误。这个区域也是线程共享的。
   虚拟机栈：存储所有被调用的java方法的上下文。push和pop。倘若在main方法里面递归调用main方法，则虚拟机栈则会被消耗光资源，造成StackOverflowError错误。这个区域是线程隔离的，也就是说每个线程都有一个虚拟机栈。
   本地方法栈：本地方法栈与虚拟机栈类似，只不过本地方法栈中存储所有被调用的本地native方法的上下文。这个区域也是线程隔离的。
   程序计数器：存储着CPU下一条指令的地址，也就是说记录着现在程序执行到了哪里，执行到了那条语句，哪个指令。这个区域也是线程隔离的。

**了解过GcRoot吗？**

::

   GcRoot是垃圾回收算法中判断一个对象是否可以回收的一种算法，判断对象到达GcRoot的路径是否还有可达，即是否有可引用链。
   可作为GC Roots的对象：
   虚拟机栈（栈帧中的本地变量表）中引用的对象
   方法区中类静态属性引用的对象
   方法区中常量引用的对象
   本地方法栈中JNI（Native方法）引用的对象

**Java内存溢出常见情况？**

::

   java.lang.OutOfMemoryError: Java heap space ------>java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。

   java.lang.OutOfMemoryError: PermGen space ------>java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。

   java.lang.StackOverflowError ------> 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。

**Java类加载机制？**

::

   类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。

   JVM将class文件字节码文件加载到内存中， 并将这些静态数据转换成方法区中的运行时数据结构，在堆(并不一定在堆中，HotSpot在方法区中)中生成一个代表这个类的java.lang.Class 对象，作为方法区类数据的访问入口。

   系统自带的类加载器分为三种：
   1. 启动类加载器。
   2. 扩展类加载器。
   3. 应用程序类加载器。

   类加载分为动态加载和静态加载。
   静态加载。通过new关键字来创建Test的实例对象。
   Test test = new Test();

   动态加载方式一。 通过Class.forName()来加载类，然后调用类的newInstance()方法实例化对象。
   Class Test = Class.forName("Test");
   Object test = Test.newInstance();

   动态加载方式二。通过类加载器的loadClass()方法来加载类，然后调用类的newInstance()方法实例化对象。
   Class Test = classLoader.loadClass("Test");
   Object test = Test.newInstance();

   动态加载是从外存储器中加载类，一般类加载机制分析的也是动态加载。
   静态加载本质上是从内存中创建类的实例对象，此时类已经被加载到内存中。

**volatile用法？**

::

   一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
   1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
   2）禁止进行指令重排序。

**聊聊死锁？**

::

   死锁是指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所站用不会释放的资源而处于的一种永久等待状态。

   死锁的四个必要条件:
   互斥条件(Mutual exclusion)
   请求与保持条件(Hold and wait)
   非剥夺条件(No pre-emption)
   循环等待条件(Circular wait)

   互斥条件(Mutual exclusion)：资源不能被共享，只能由一个进程使用。
   请求与保持条件(Hold and wait)：已经得到资源的进程可以再次申请新的资源。
   非剥夺条件(No pre-emption)：已经分配的资源不能从相应的进程中被强制地剥夺。
   循环等待条件(Circular wait)：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。

   java中产生死锁可能性的最根本原因是：1）是多个线程涉及到多个锁，这些锁存在着交叉，所以可能会导致了一个锁依赖的闭环；2）默认的锁申请操作是阻塞的。
   线程在获得一个锁L1的情况下再去申请另外一个锁L2，也就是锁L1想要包含了锁L2，在获得了锁L1，并且没有释放锁L1的情况下，又去申请获得锁L2，这个是产生死锁的最根本原因。

   避免死锁:
   方法一：破坏死锁的循环等待条件。
   方法二：破坏死锁的请求与保持条件，使用lock的特性，为获取锁操作设置超时时间。这样不会死锁（至少不会无尽的死锁）。
   方法三：设置一个条件遍历与一个锁关联。该方法只用一把锁，没有chopstick类，将竞争从对筷子的争夺转换成了对状态的判断。仅当左右邻座都没有进餐时才可以进餐。提升了并发度。

**聊聊内存泄漏？**

::

   1. 当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。
   2. 通常我们可以借助MAT、LeakCanary等工具来检测应用程序是否存在内存泄漏。
   3. 单例造成的内存泄漏
   4. 非静态内部类创建静态实例造成的内存泄漏
   5. Handler造成的内存泄漏
   6. 线程造成的内存泄漏
   7. 资源未关闭造成的内存泄漏
   8. 使用ListView时造成的内存泄漏
   9. 集合容器中的内存泄露
   10. WebView造成的泄露

**强引用、软引用、弱引用、虚引用的区别？**

::

    如果一个对象具有强引用，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
   我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。

   如果一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。软引用可用来实现内存敏感的高速缓存。软引用在实际中有重要的应用，例如浏览器的后退按钮。如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出。
   这时候就可以使用软引用。

   弱引用与软引用的区别
   只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

   如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。

   虚引用与软引用和弱引用的区别
   虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

   说白了jvm就像一个国家，gc就是城管，强引用就是当地人，软引用就是移民的人，弱引用就是黑户口，哪天城管逮到就遣走，虚引用就是一个带病的黑户口，指不定哪天自己就挂了。

**Java里内存泄漏和溢出的区别？**

::

   内存泄露是垃圾回收机制中，垃圾没有回收导致的内存持续占用。
   内存溢出是指内存不够用了。

**Java里Integer和int的区别？**

::

   Integer是int的包装类，必须实例化以后才能使用。
   int是基本数据类型。

**Integer和int如何比较相等？**

::

   Integer之间比较要用equals，用==比较地址。
   Integer和int比较直接用==，会自动拆箱。

**protected，public，private的区别？**

::

   public 任何人都是可用的。
   private 除类型创建者和类型的内部方法之外的任何人都不能访问。
   protected 与private作用相当，差别仅在于继承的类可以访问protected成员。

**List和ArrayList的区别？**

::

   List是一个接口，而ArrayList是List接口的一个实现类。 
   ArrayList继承AbstractList抽象类。

**接口和抽象类能被实例化吗？**

::

   接口和抽象类都不能被实例化，但是它们可以创建一个指向自己的对象引用，它们的实现类或子类就在充当这样的角色。这就是面向对象编程中多态的优势。

**ArrayList和HashSet区别？**

::

   ArrayList元素可重复。HashSet不能重复。
   ArrayList中存放顺序和添加顺序是一致的。HashSet存储是无序的。
   ArrayList是线性结构。HashSet是散列结构。

**Java内存结构？**

::

   大体可以分成堆内存、栈、方法区。

**全局变量，临时变量，静态变量分别存在哪里？**

::

   全局变量存放在堆
   临时变量存放在栈
   静态变量存放在方法区

   扩展：
   堆分为新生代、老生代。
   新生代包含一块eden和俩块surviver区，默认比例是8:1:1。
   新生代经历过一定数量gc【默认15次】还没回收的对象晋升老年代。

**给出一个int类型123，写一个函数，返回反转的值321？**

::

   public static void main(String[] args) {
       int i = 123;
       String si = i + "";
       int ir = Integer.parseInt(new StringBuffer(si).reverse().toString());
       System.out.println(ir);
   }

**判定一个对象是否要被回收的方法？**

::

   引用计数法
   可达性分析

**线程安全在Java中是如何实现的？**

::

   synchronized 同步锁

**HashMap，HashTable，ConcurrentHashMap？**

::

   HashMap 继承于AbstractMap，可存储null键和值， 线程不安全。  
   HashTable 继承于Dictionary, 不可存储null键和值， 父类方法少于AbstractMap, 只有基本的get, put, remote, 没有putAll, keySet等， 线程安全。
   ConcurrentHashMap 继承于AbstractMap, 不能存储null键和值， 线程安全。

**HashSet判断存入的对象是否重复？**

::

   首先会调用hashCode方法判断hashCode是否已经存在，如不存在则直接插入元素。
   如果已存在则调用equals方法判断是否返回true，如果为true则说明元素已经存在，如为false则插入元素。

**JAVA反射机制？**

::

   JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。
   对于任意一个对象，都能够调用它的任意一个方法和属性。
   这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

**类对象？**

::

   实际上，我们创建的每一个类也都是对象，即类本身是java.lang.Class类的实例对象。
   Class类没有公共构造方法。Class对象是在加载类时由 Java 虚拟机自动构造的。
   Class对象用于提供类本身的信息，比如有几种构造方法， 有多少属性，有哪些普通方法。

**Java泛型？**

::

   Java泛型，是指把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型。

   使用泛型的好处：
   约定集合中的类型
   避免类型混乱抛java.lang.ClassCastException

**类加载器有哪3类？**

::

   类的加载器可分为3类：启动类加载器，扩展类加载器，应用程序类加载器。

**List、Set、数组类型转化？**

::

   List转数组
   String[] array = (String[])list.toArray(new String[size]);

   List转Set
   Set<String> set = new HashSet(list);

   数组转换为List
   List<String> list = new ArrayList<>(Arrays.asList(array));

   数组转换为Set
   Set<String> set = new HashSet(Arrays.asList(array));

   Set转List
   List<String> list=new ArrayList<>(set);

   Set转数组
   String[] array=set.toArray(new String[0]);

   数组 .length()
   List .size()

**如何防止数组越界？**

::

   数组取值时检查index
   try catch

**Java中collection的sort方法，默认的排序方法是什么？**

::

   ASCII码，升序。

**给定一个整数数组 nums和一个目标值
target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。**

::

   class Solution {
       public int[] twoSum(int[] nums, int target) {
           Map<Integer, Integer> map = new HashMap<>();
           for (int i = 0; i < nums.length; i++) {
               int complement = target - nums[i];
               if (map.containsKey(complement)) {
                   return new int[]{map.get(complement), i};
               }
               map.put(nums[i], i);
           }
           throw new IllegalArgumentException("No two sum solution");
       }
   }

**Servlet执行过程？**

::

   用户请求一个Servlet，Servlet容器自动构建请求和响应对象，然后执行Servlet的service()方法，该方法会接收请求和响应对象，通过响应对象将处理结果发送给用户。

**Java八大基本数据类型？**

::

   byte
   short
   int
   long
   float
   double
   boolean
   char
      
   如果再问 +1 void

**Java中堆和栈有什么区别？**

::

   栈内存存储的是局部变量而堆内存存储的是实体。
   栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短。
   栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。

**二分查找？**

::

   /**
    * 使用递归的二分查找
    * title:recursionBinarySearch
    *
    * @param arr 有序数组
    * @param key 待查找关键字
    * @return 找到的位置
    */
   public static int recursionBinarySearch(int[] arr, int key, int low, int high) {

       if (key < arr[low] || key > arr[high] || low > high) {
           return -1;
       }

       int middle = (low + high) / 2;            //初始中间位置
       if (arr[middle] > key) {
           //比关键字大则关键字在左区域
           return recursionBinarySearch(arr, key, low, middle - 1);
       } else if (arr[middle] < key) {
           //比关键字小则关键字在右区域
           return recursionBinarySearch(arr, key, middle + 1, high);
       } else {
           return middle;
       }

   }

**哈希表的实现原理？**

::

   把Key通过哈希函数转换成一个整型数字，然后将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。

**现在有100W个账户密码，要存起来，要求查找时速度尽可能快，你选择什么数据结构？为什么？**

::

   HashMap，因为其查找速度与数据量基本无关，是常数级别。
   但是对空间的要求很高，以空间换时间。

**什么是AOP？**

::

   Sping AOP Aspect Oriented Programming，面向切面编程。
   AOP可以实现“业务代码”与“关注点代码”分离。关注点代码，就是指重复执行的代码。
   Spring采用jdk动态代理模式来实现Aop机制。
   Spring AOP采用动态代理过程：
   1.将切面使用动态代理的方式动态植入到目标对象，形成一个代理对象。
   2.目标对象如果没有实现代理接口，那么spring会采用CGLib来生成代理对象，该代理对象是目标对象的子类。
   3.目标对象如果是final类，也没有实现接口，就不能运用AOP。

.. |image1| image:: ../wanggang.png
