3 算法
======

|image1|

**LeetCode刷题记录：https://github.com/dongfanger/leetcode-python。**

**给定数组[5, 3, 2, 6, 1, 4]，请实现冒泡排序，从小到大。**

.. code:: python

   a = [5, 3, 2, 6, 1, 4]

   n = len(a)
   for i in range(n - 1):
       for j in range(n - 1 - i):
           if a[j] > a[j + 1]:
               a[j], a[j + 1] = a[j + 1], a[j]

**string = “192.0.0.1?!289.0.0.1!0.0.0.0!192.163.10.28?192.0.0.1”
要求：返回一个IP数组，并且按IP最后一位排序返回。
P.S.语言随意，只需要能够正确排序返回接口。（Java、Python、Shell均可）**

.. code:: python

   import re

   s = "192.0.0.1?!289.0.0.1!0.0.0.0!192.163.10.20?192.0.0.1"
   ips = re.split(r"\?!|!|\?", s)


   def lastOne(i):
    return i.split('.')[-1]


   ips.sort(key=lastOne)
   print(ips)

**全排列，是把一堆字符按照一定的顺序排列起来，所有可能的组合。
比如，“123”的全排列为“123”、“132”、“213”、“231”、“312”、“321”。
请用Python实现全排列。**

.. code:: python

   test_list = ['x', 'y', 'z']


   def permutations(sequence, i):
    if i == (len(sequence) - 1):
        print(str(sequence))
    else:
        for j in range(i, len(sequence)):
            sequence[i], sequence[j] = sequence[j], sequence[i]
            permutations(sequence, i + 1)
            sequence[i], sequence[j] = sequence[j], sequence[i]


   permutations(test_list, 0)

**给定一个不确定的Json对象，求Json子节点的最大深度。**

.. code:: java

   package test;

   import net.sf.json.JSONObject;

   import java.util.Iterator;

   public class AProblemDiGui {
       static int count = 0;

       public static void main(String[] args) {
           String param = "{\"ext_meta\":{\"id\":4332021940090402,\"uid\":0,\"similarity\":1,\"blockOid\":{\"id\":4332021940090402,\"uid\":0,\"similarity\":\"1239545\",\"blockOid\":null,\"blockTopicMd5\":null},\"blockTopicMd5\":{\"id\":4332021940090402,\"uid\":0,\"similarity\":\"1239545\",\"blockOid\":{\"id\":4332021940090402,\"uid\":0,\"similarity\":\"1239545\",\"blockOid\":null,\"blockTopicMd5\":null},\"blockTopicMd5\":null}}, \"msg\":\"found\",\"ext_meta1\":{\"id\":4332021940090402,\"uid\":0,\"similarity\":\"1239545\",\"blockOid\":null,\"blockTopicMd5\":null}}";
           System.out.println(getLength(param));
       }

       static public int getLength(String temp) {
           Boolean flag = true;
           JSONObject jsonObject = JSONObject.fromObject(temp);
           Iterator iteratorValue = jsonObject.values().iterator();
           Iterator iteratorKey = jsonObject.keySet().iterator();
           while (iteratorValue.hasNext()) {
               String value = iteratorValue.next().toString();
               System.out.println(iteratorKey.next() + ":" + value);
               if (value.startsWith("{")) {
                   if (flag) {  //单层只记录一次
                       count++;
                       flag = false;
                   }
                   int tmp = getLength(value);
                   if (tmp > count)
                       count = tmp;
               }
           }
           return count;
       }
   }

**算法性能主要受哪些因素影响？**

::

   编程语言；数据结构；数据类型；数据规模；运行环境。

**两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比。请编程序找出三队赛手的名单。**

.. code:: python

   import itertools

   for i in itertools.permutations('xyz'):
     if i[0] != 'x' and i[2] != 'x' and i[2] != 'z':
         print('a vs %s, b vs %s, c vs %s' % (i[0], i[1], i[2]))

**给你一个字符串，你怎么判断是不是ip地址？手写这段代码。**

::

   public static void main(String[] args) {
       Scanner scanner = new Scanner(System.in);
       String ipStr = scanner.next();
       boolean isIpLegal = isIpLegal(ipStr);
       if (isIpLegal) {
           System.out.println(ipStr + " 合法");
       } else {
           System.out.println(ipStr + " 非法");
       }
   }

   public static boolean isIpLegal(String ipStr) {
      String ipRegEx = "^([1-9]|([1-9][0-9])|(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5]))(\\.([0-9]|([1-9][0-9])|(1[0-9][0-9])|(2[0-4][0-9])|(25[0-5]))){3}$";
     Pattern pattern = Pattern.compile(ipRegEx);
     Matcher matcher = pattern.matcher(ipStr);
     if (matcher.matches()) {
      return true;
     } 
       else {
           return false;
       }
   }

**判断闰年的标准是：能整除4且不能整除100，能整除400。设定合法的年份为1-9999。**

::

   public class Test2 {
       public static void main(String[] args) {
           Scanner in = new Scanner (System.in);
           int year=in.nextInt();
           if(year<=0||year>9999) {
               System.out.println("请输入正确的年份");
           }
           if((year%4==0&&year%100!=0)||year%400==0) {
               System.out.println("闰年");
           } else {
               System.out.println("不是闰年");
           }
       }
   }

**二叉树的深度计算？**

::

   如果一棵树只有一个结点，它的深度为1。
      
   如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。计算左子树深度和右子树深度同理（即将当前左或右子树节点看做根节点）。
      
   如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值加1。
      

   class Solution:
        #二叉树的深度
       def TreeDepth(self, pRoot):
       # write code here
           global maxdepth#全局变量保存当前最长的路径长度
           maxdepth=0
           def DfsTree(root,depth=0):#depth是当前的路径长度
               global maxdepth
               if root:#节点非空，路径长度加1
                   depth+=1
               if root.left:#左子树非空，继续遍历左子树
                   DfsTree(root.left,depth)
               if root.right:#右子树非空，继续遍历右子树
                   DfsTree(root.right,depth)
               if not root.left or root.right:#左右子树都是空的，即该节点是一个叶子结点，则判断depth是不是最长的路径
                   if depth>maxdepth:
                       maxdepth=depth
           if root:
               DfsTree(root)
           return maxdepth

.. |image1| image:: ../wanggang.png
