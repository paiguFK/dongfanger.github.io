3 TestNG的代码组织层级
======================

|image1|

大家好，我是刚哥。

TestNG有3种代码组织层级：测试方法（Test methods）、测试类（Test
classes）、测试组（Test groups）。

Test methods、Test classes
--------------------------

**使用了@Test注解的方法就是测试方法，包含测试方法的类就是测试类。**\ 比如：

.. code:: java

   package example1;
    
   import org.testng.annotations.*;
    
   public class SimpleTest {
    
    @BeforeClass
    public void setUp() {
      // code that will be invoked when this test is instantiated
    }
    
    @Test(groups = { "fast" })
    public void aFastTest() {
      System.out.println("Fast test");
    }
    
    @Test(groups = { "slow" })
    public void aSlowTest() {
       System.out.println("Slow test");
    }
    
   }

这个很好理解，但是有个特殊点是@Test注解的测试方法，默认是会忽略返回值的，除非在testng.xml配置：

.. code:: xml

   <suite allow-return-values="true">
    
   or
    
   <test allow-return-values="true">

Test groups
-----------

测试分组其实就是给测试方法打标记，比如冒烟测试用例和功能测试用例：

.. code:: java

   public class Test1 {
     @Test(groups = { "functest", "checkintest" })
     public void testMethod1() {
     }
    
     @Test(groups = {"functest", "checkintest"} )
     public void testMethod2() {
     }
    
     @Test(groups = { "functest" })
     public void testMethod3() {
     }
   }

如果只配置functest，就会执行全部测试方法：

.. code:: xml

   <test name="Test1">
     <groups>
       <run>
         <include name="functest"/>
       </run>
     </groups>
     <classes>
       <class name="example1.Test1"/>
     </classes>
   </test>

如果只配置checkintest，就会只执行前面2个方法：

.. code:: xml

   <test name="Test1">
     <groups>
       <run>
         <include name="checkintest"/>
       </run>
     </groups>
     <classes>
       <class name="example1.Test1"/>
     </classes>
   </test>

除了指定完整name，也可以使用正则表达式：

.. code:: java

   @Test
   public class Test1 {
     @Test(groups = { "windows.checkintest" })
     public void testWindowsOnly() {
     }
    
     @Test(groups = {"linux.checkintest"} )
     public void testLinuxOnly() {
     }
    
     @Test(groups = { "windows.functest" )
     public void testWindowsToo() {
     }
   }

.. code:: xml

   <test name="Test1">
     <groups>
       <run>
         <include name="windows.*"/>
       </run>
     </groups>
    
     <classes>
       <class name="example1.Test1"/>
     </classes>
   </test>

进一步，测试分组除了include测试方法，还可以exclude：

.. code:: xml

   <test name="Test1">
     <classes>
       <class name="example1.Test1">
         <methods>
           <include name=".*enabledTestMethod.*"/>
           <exclude name=".*brokenTestMethod.*"/>
         </methods>
        </class>
     </classes>
   </test>

..

   还有一个办法是使用\ *@Test*\ 和\ *@Before/After*\ 的\ ``enabled``\ 属性。

测试分组也能进行嵌套：

.. code:: xml

   <test name="Regression1">
     <groups>
       <define name="functest">
         <include name="windows"/>
         <include name="linux"/>
       </define>
     
       <define name="all">
         <include name="functest"/>
         <include name="checkintest"/>
       </define>
     
       <run>
         <include name="all"/>
       </run>
     </groups>
     
     <classes>
       <class name="test.sample.Test1"/>
     </classes>
   </test>

``<define></define>``\ 定义了父分组，里面\ ``<include>``\ 的就是子分组。

同样的，嵌套分组也可以对子分组进行exclude：

.. code:: java

   @Test(groups = {"checkintest", "broken"} )
   public void testMethod2() {
   }

.. code:: java

   <test name="Simple example">
     <groups>
       <run>
         <include name="checkintest"/>
         <exclude name="broken"/>
       </run>
     </groups>
     
     <classes>
       <class name="example1.Test1"/>
     </classes>
   </test>

最后，对于分组的位置，如果测试类和测试方法都标记了分组，那么测试类的分组会作用到所有方法中，比如：

.. code:: java

   @Test(groups = { "checkin-test" })
   public class All {
    
     @Test(groups = { "func-test" )
     public void method1() { ... }
    
     public void method2() { ... }
   }

method2()属于checkin-test分组，method1属于func-test和checkin-test两个分组。

   参考资料：

   https://testng.org/doc/documentation-main.html 5 - Test methods, Test
   classes and Test groups

.. |image1| image:: ../wanggang.png
